<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CapLine TazzoX - Live Translation</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Socket.IO client via CDN -->
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #020617;
      color: #e5e7eb;
      min-height: 100vh;
      display: flex;
    }
    .sidebar {
      position: fixed;
      left: 32px;
      top: 32px;
      width: 320px;
      padding: 22px 22px 18px;
      border-radius: 24px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: radial-gradient(circle at top, rgba(15,23,42,0.96) 0, rgba(15,23,42,0.92) 45%, rgba(15,23,42,0.85) 100%);
      box-shadow:
        0 0 40px rgba(15, 23, 42, 0.9),
        0 30px 80px rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(24px);
      box-sizing: border-box;
      z-index: 10;
    }
    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      padding-left: 360px;
      padding-top: 40px;
      padding-bottom: 140px; /* leave room for bottom panel so it doesn't overlap orb */
    }
    .title {
      font-size: 22px;
      font-weight: 600;
      letter-spacing: 0.03em;
      margin-bottom: 4px;
    }
    .subtitle {
      font-size: 11px;
      opacity: 0.7;
      margin-bottom: 20px;
    }
    label {
      display: block;
      font-size: 12px;
      opacity: 0.8;
      margin-bottom: 6px;
    }
    select, input {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(3,8,24,0.95);
      color: #f5f5f5;
      font-size: 13px;
      box-sizing: border-box;
      margin-bottom: 12px;
    }
    button {
      width: 100%;
      padding: 10px 12px;
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, #47c2ff, #6f5bff);
      color: white;
      font-weight: 600;
      font-size: 13px;
      cursor: pointer;
      margin-top: 8px;
    }
    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
    .status {
      font-size: 11px;
      opacity: 0.7;
      margin-top: 10px;
    }
    .viz-container {
      position: relative;
      width: min(380px, 60vw);  /* medium size */
      height: min(380px, 60vw);
      border-radius: 999px;
      overflow: hidden;
      box-shadow:
        0 0 80px rgba(56, 189, 248, 0.45),
        0 0 160px rgba(59, 130, 246, 0.45);
      background: radial-gradient(circle at 20% 0, #1d4ed8 0, transparent 60%),
                  radial-gradient(circle at 80% 100%, #db2777 0, transparent 60%),
                  radial-gradient(circle at 10% 100%, #22c55e 0, transparent 55%);
    }
    .viz-container img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      mix-blend-mode: screen;
    }
    .live-pill {
      position: absolute;
      top: 24px;
      right: 24px;
      font-size: 11px;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(255, 56, 96, 0.18);
      color: #ff7b9d;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #ff3b6a;
      animation: pulse 1.2s infinite ease-out;
    }
    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      100% { transform: scale(2.4); opacity: 0; }
    }
    .transcript-panel {
      position: absolute;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      width: min(820px, 92vw);
      background: radial-gradient(circle at 0 0, rgba(37, 99, 235, 0.26) 0, transparent 55%),
                  rgba(15, 23, 42, 0.88);
      border-radius: 24px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      backdrop-filter: blur(22px);
      padding: 16px 20px 12px;
      box-sizing: border-box;
      box-shadow: 0 26px 50px rgba(15, 23, 42, 0.85);
    }
    .transcript-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      opacity: 0.7;
      margin-bottom: 4px;
    }
    .transcript-text {
      font-size: 15px;
      line-height: 1.4;
      min-height: 24px;
    }
    .arch-note {
      font-size: 11px;
      opacity: 0.6;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <aside class="sidebar">
    <div class="title">CapLine TazzoX</div>
    <div class="subtitle">Enhanced Multi‑Party Speech Translation (Single Target Mode)</div>

    <label for="sessionId">Session ID</label>
    <input id="sessionId" value="room-1" />

    <label for="speakerId">Your Name / ID</label>
    <input id="speakerId" value="Speaker-1" />

    <label for="sourceLang">Your Language (You Speak)</label>
    <select id="sourceLang">
      <option value="English">English</option>
      <option value="Hindi">Hindi</option>
      <option value="Bengali">Bengali</option>
      <option value="Spanish">Spanish</option>
      <option value="French">French</option>
      <option value="German">German</option>
      <option value="Japanese">Japanese</option>
      <option value="Turkish">Turkish</option>
      <option value="Arabic">Arabic</option>
      <option value="Portuguese">Portuguese</option>
    </select>

    <label for="targetLang">Target Language</label>
    <select id="targetLang">
      <option value="English">English</option>
      <option value="Hindi">Hindi</option>
      <option value="Bengali">Bengali</option>
      <option value="Spanish">Spanish</option>
      <option value="French">French</option>
      <option value="German">German</option>
      <option value="Japanese">Japanese</option>
      <option value="Turkish">Turkish</option>
      <option value="Arabic">Arabic</option>
      <option value="Portuguese">Portuguese</option>
    </select>

    <button id="connectBtn">Connect & Start Mic</button>
    <button id="disconnectBtn" disabled>Stop</button>

    <div class="status" id="statusText">Idle. Not connected.</div>

    <div class="arch-note">
      Input · Processing · Control Modules · Translation & Synthesis · Output
      are running continuously in the backend.
    </div>
  </aside>

  <main class="main">
    <div class="live-pill"><span class="dot"></span> LIVE TRANSLATION</div>

    <div class="viz-container">
      <!-- Place your GIF as backend/static/visualizer.gif -->
      <img src="{{ url_for('static', filename='visualizer.gif') }}" alt="Live visualizer" />
    </div>

    <section class="transcript-panel">
      <div class="transcript-label">Translated Output</div>
      <div id="translatedText" class="transcript-text"></div>
      <audio id="translatedAudio" controls style="margin-top:8px; width:100%; background:transparent;">
        Your browser does not support the audio element.
      </audio>
    </section>
  </main>

  <script>
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const statusText = document.getElementById('statusText');
    const translatedTextEl = document.getElementById('translatedText');
    const translatedAudioEl = document.getElementById('translatedAudio');

    let mediaRecorder = null;
    let recordedChunks = [];
    let lastAudioUrl = null;

    function setStatus(text) {
      statusText.textContent = text;
    }

    async function startRecording() {
      const sourceLang = document.getElementById('sourceLang').value || 'English';
      const targetLang = document.getElementById('targetLang').value || 'Hindi';

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

        let options = {};
        if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
          options = { mimeType: 'audio/webm;codecs=opus' };
        }

        mediaRecorder = new MediaRecorder(stream, options);
        recordedChunks = [];

        mediaRecorder.addEventListener('dataavailable', (e) => {
          if (e.data && e.data.size > 0) {
            recordedChunks.push(e.data);
          }
        });

        mediaRecorder.start();
        setStatus('Recording... Speak into your microphone. Click Stop to translate.');
        connectBtn.disabled = true;
        disconnectBtn.disabled = false;
        translatedTextEl.textContent = '';
      } catch (err) {
        console.error(err);
        setStatus('Could not start: ' + err.message);
      }
    }

    async function stopAndTranslate() {
      const targetLang = document.getElementById('targetLang').value || 'Hindi';

      if (!mediaRecorder) return;

      mediaRecorder.addEventListener('stop', async () => {
        try {
          const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType || 'audio/webm' });

          const formData = new FormData();
          formData.append('audio', blob, 'recording.webm');
          formData.append('target_language', targetLang);
          formData.append('source_language', sourceLang);

          setStatus('Uploading & translating...');

          const response = await fetch('/translate', {
            method: 'POST',
            body: formData,
          });

          const result = await response.json();

          if (!response.ok || result.error) {
            throw new Error(result.error || 'Translation failed');
          }

          translatedTextEl.textContent = result.translated_text || '';
          setStatus('Done. Playing translated audio...');

          // Play translated audio if provided
          if (result.audio_base64) {
            try {
              // Clean up previous audio URL
              if (lastAudioUrl) {
                URL.revokeObjectURL(lastAudioUrl);
                lastAudioUrl = null;
              }

              const byteString = atob(result.audio_base64);
              const byteArray = new Uint8Array(byteString.length);
              for (let i = 0; i < byteString.length; i++) {
                byteArray[i] = byteString.charCodeAt(i);
              }

              const blob = new Blob([byteArray], { type: 'audio/mpeg' });
              lastAudioUrl = URL.createObjectURL(blob);

              // Attach to persistent audio player
              translatedAudioEl.src = lastAudioUrl;
              translatedAudioEl.load();
              translatedAudioEl.play().catch(err => {
                console.warn('Autoplay blocked, use play button.', err);
              });
            } catch (e) {
              console.error('Failed to play translated audio', e);
            }
          } else {
            setStatus('Done. (No audio returned)');
          }
        } catch (err) {
          console.error(err);
          setStatus('Error: ' + err.message);
        }
      }, { once: true });

      mediaRecorder.stop();
      connectBtn.disabled = false;
      disconnectBtn.disabled = true;
    }

    connectBtn.addEventListener('click', () => {
      startRecording();
    });

    disconnectBtn.addEventListener('click', () => {
      stopAndTranslate();
    });
  </script>
</body>
</html>
